# コーディング段階

- プロジェクトがコーディング段階に入ると機会的に実行可能？
- こうした考えはシステムを悪くする
- コーディングは機会的な作業ではない
- 本能的で無意識の思考を活用できるようになる
- コードについて積極的に考えようとしない開発者は偶発的にプログラミングを実践している
- 自分自信で書いたコードに常に批判的な目を向ける
- テストはバグを発見するためのものではない
    - コードのフィードバック、設計やAPI、結合といった観点をえるためのもの
    - テストの主な利点は、テストについて考え、テストを生み出しているときに生み出される
- 名前によって作り出す現実そのものが様々な形で定義されていくことになる
- 状況を再検討し、問題の可能性をチェックし、不測の事態に備えている

## 爬虫類脳からの声に耳を傾ける

- 洗練された人間として、憤らんお本能、爬虫類脳を理解するように学習してきた
- プログラマーとして経験を積んでいくとともに、うまくいくものごと、うまく行かないものごと、問題が起こりそうな状況が蓄積されていく
- 無意識のうちに脳の「ファイル保存」ボタンが押されてリウ
- 本能は言葉で表せない

### 空白ページの恐怖

- 作業に対して最初の一歩を遅らせようとする原因
    - 作業を前にしてなにか疑いが感じられる場合や気が進まない場合、過去の経験が何かを伝えようとしているのかもしれない
    - 単に失敗を恐れている

### 自らと戦う

- コーディングがぬかるんだ上り坂を登っていくように感じられるとき
- コードが何かを伝えようとしている
    - 構造や設計が間違っている
    - 誤った問題を解決しようとしている
    - 星の数くらいの多くのバグを作ろうとしている

### 爬虫類脳との対話方法

- **爬虫類脳に耳を傾ける**
- 作業の手を止める
    - キーボードから少し離れて別のことをする
- 問題を具体的な形にして表現してみる
    - 開発中のコードに関することをチラシの裏に書き付けてみる
    - プログラマー以外の同僚に説明してみる
- 脳の違った部分を用いて問題が他のやり方で扱えないかを見極める
- プロトタイピングして、今からやろうとしていることがそれほど大きな話でないと脳に伝える

### お遊びの時間

- 自分自身に向けて、プロトタイプの必要性を呼びかける
- プロジェクトで探求したい側面に目を向ける
    - 新しいフレームワークを使っている
    - データの束縛方法について深ぼる
    - アルゴリズムで境界条件の動作を探求する
    - ユーザーインタラクションの方法を今までと違った形にする
- 既存のコードを相手に手こずっている場合
    - ポストイットに「現在プロトタイピング中」と書いて、画面の横に貼る
    - 失敗するために実施するということを忘れない
    - 失敗しなかったとしてもプロトタイプは捨て去る
    - 実行すること、学習することを1行にまとめてまっさらなエディタの画面にコメントとして記述
    - コーディングを開始
- コーディング中にぼんやりとした不安が具体化したら、その問題に取り組む
- 意外と楽しくコードを記述できることに気づく
    - そうしたら作業に戻れば良い！

### 「あなたのコード」だけではない

- 他人のコードと格闘することも作業の多くになる
- コードを機械的に読みすすめ、重要と思われる内容をコメントしていくことも無益でない
- ちょっとした実験
    - 見知らぬ方法で実装されているところを見つけたら手早くメモる
    - パターンが見つかるとコードへの理解が一気に深まる

### コードに留まらない

- コード以外でも要件定義や設計時にも不安を感じたら、立ち止まって分析するようにする

## 偶発的プログラミング

- 開発者も地雷原で働いているようなもの
- 幸運と行き当たりばったりの成功に頼るような偶発的プログラミングを避けて、「慎重なプログラミング」を選ぶべき

### 偶発的プログラミングの方法

- なぜコードが動いていたかを理解していなかったので動かなかったときもその理由がわからなかった
- 偶然の結果と意図的な行為の結果をごちゃまぜにしてしまうこともある

実装の事故

- コードが現在そのように記述されているという、ただそれだけの理由で発生する
- ドキュメント化されていないエラーや境界条件に頼っている点からくる
- 「とにかく今動いているんだから触らないほうがいいな」が間違っている理由
    - 本当は動いているように見えて動いていないかもしれない
    - 前提としている境界条件は偶発的なものであるかもしれない（画面解像度、CPUコア数）
    - ライブラリの次のリリースでドキュメント化されていない動作がへんこうになるかもしれない
    - 不必要な呼び出しが余分にあるとコードの実行が遅くなる
    - 余計な呼び出しによって、新たなバグを混入させてしまう危険性がある
- 他人の使うコードを開発している場合、基本原則を適用する
    - 正しいモジュール
    - コンパクトかつ上手にドキュメント化されたインタフェースの背後に実装を隠す
    - [契約による設計]()
- 機能を呼び出すときには。ドキュメント化された振る舞いのみを前提とする

十分近い、というのは外れも同じ

- e.g タイムゾーンの1時間を許容したらコードに意味不明な+1や-1が増えていた

幻のパターン

- つるふさの法則
    - 偶然でも、パターンと原因を見極めようとする
- 仮定でなく証明が必要

コンテキストの事故

- モジュールはGUIを前提としたものでよいか？
- ユーザーは日本語を話すことを前提としてよいか？
- 読み書きができるユーザーを前提として良いか？
- カレントディレクトリが書込み可能であることを前提としていないか？
- 環境変数や設定ファイルの存在が前提になっていないか？
- サーバーが正常に動作している際にどの程度の許容度があるか
- ネットワークの可用性と速度に依存していないか
- あなたが前提としていることで、保証できないものはないか？
- コードをコピーする際には、同じコンテキストにあるといってよいか
- **偶発的プログラミングを行わないこと**

暗黙の仮定

- すべての段階で、人々は心のなかに多くの仮定を置いている
- こうした仮定はドキュメント化されることははほとんどない

### 慎重なプログラミングの方法

- 何をやっているのかを意識する
    - [石のスープとゆでガエル]() のようにならないように
- 新人プログラマーに対して、コードの詳細を説明できるように
- 完全に理解していないアプリケーションをを作成したり、なじみのない技法を使わない
- 明確なプランを作る
- 信頼のおけるものごとだけを前提とする
- 仮定をドキュメント化する
- コードだけでなく、置いた仮定もテストする
    - [表明]()を記述する
- 作業に優先順位をつけ、重要な部分に時間をかけるようにする
- 陳腐化したコードがあったら、それが全部でも置き換える

## アルゴリズムのスピード

- アルゴリズムや消費する時間やプロセッサ、メモリなどのリソースの見積もりを行う

### アルゴリズム見積もりとは

- アルゴリズムの入力サイズに対する計算量
- より詳細な分析を行う必要があるときにはO記法を使う

### O記法

- 測定対象の上限値を表すもの

### 見積もりについての一般的心得

- 単純ループ $O(n)$
    - 順次検索、配列中の最大値取得、チェックサムの生成
- ネストしたループ $O(n^2)$
    - バブルソート
- 二分割 $O(lg(n))$
    - クイックソート
- 組み合わせ
    - 巡回セールスマン問題、ナップサック問題、数値の集合を分割して各集合の合計を同じにする

### 現実的なアルゴリズムのスピード

- ソートの処理を仕事で開発するようなことはないはず：ライブラリを使用する
- 単純なループを記述するときでもオーダーを意識する
- **アルゴリズムのオーダーを見積もること**
- コードの実行時間やメモリの使用量がわからないのであれば、入力件数や実行時間に影響を与えそうなものを変えてみて実行してみて確認する
    - 実際に測定、グラフ化
- コード自身が何をしているのかを考慮
    - nが小さい場合には別の方が早くなることお
- 達人プログラマーあは理論面および現実面の双方でものごとを考えなければならない
- 見積もりの本来の目的は、本番環境上で実際のデータを使ってそのコードを実行したときの速度
- **見積もりの検証を行うこと**

最善は常に最善ではない

- 最高速のアルゴリズムが今の仕事にとって最善のものであるとは必ずしもいえない
- 時期尚早な最適化にも注意が必要
    - アルゴリズムの改良は、それが本当にボトルネックになっていることを確認してから行うべき

## リファクタリング

- プログラムの進化に従って、コードは変化していく
- ビルの建築というメタファーが使われるが、そう簡単にはいかない
    - 建築というよりもガーデニングに近い
- コードの書き直し、再作業、アーキテクチャの見直しを総称してリファクタリングと呼ぶ
    - このアクティビティは規律あるものであり、勝手きままに進めるものではない
    - 外部から見た振る舞いを変えることとは許されていない
        - ユニットテストによってコードのふるまいを保証する必要がある

### いつリファクタリングを行うべきなのか

- 何かを学んだk時
- 二重化
    - DRY原則に反しているものを発見した場合
- 直交していない設計
- 時代遅れの知識
- 使用方法
    - 本物のユーザーによって使用されたときに、以前は必要だと感じられていた機能よりも銃よな機能があるとわかった場合
- パフォーマンス
- テストの合格
    - 新たなコードを追加し、それに関するテストに合格したタイミングは、今記述したコードを整理するためのまたとない機会となる

現実世界の複雑さ

- リファクタリングを避ける言い訳
    - 納期
        - 今リファクタリングを避ければ、将来にそんな時間はない
        - あとになると問題は重大化する
- **早めにリファクタリングすること、そしてこまめにリファクタリングすること**

### どのようにリファクタリングするか

- リファクタリングはSmalltalkのコミュニティから生み出されたもの
- 徐々に、そして慎重かつ丁寧に行っていく
- リファクタリングと機能の追加を同時に行ってはならない
- リファクタリングを始める前に、しっかりとしたテストが用意されていることを確認
    - できる限り頻繁にテストを行う
- 各作業は、小さな単位にまとめ、慎重に進めるようにする
- 優れた回帰テストを維持するのがリファクタリングの安全性を高める鍵になる
- リファクタリングの域を超えて、外部から見た振る舞いやインターフェースを変更するという場合、意図的にビルドを破壊するという手がある
    - コードはコンパイルできなくなるが、どこを修正するのかわかるようになる

## コードのためのテスト

- **テストとはバグを見つけることではない**
- テストの利点は、テストについて考え、テストを記述しているときにあり、テストを実行しているときではない

### テストについて考える

- いきなり実装するとそれが適切かどうか判断が難しい
- テストデータから考える

### テスト駆動コーディング

- メソッドのテスト記述を考えることで、コードの開発者でなく、ユーザー観点で外部からメソッドを客観的に捉えられるようになる
- **テストはコードのユーザー第一号である**
- コードをテスト可能にするには疎結合にする必要がある
- 何かをテストする前にはそれを理解しなければならない
    - テストの境界条件をコーディング前に考えておけば、関数をコンパクトにまとめるためのパターンが見えてくる

テスト駆動開発

- TDDのサイクル
    - 追加したいごく一部の機能を決定する
    - 機能が実装されたときにパスするテストを記述する
    - すべてのテストを実行してみて、今記述したテストが失敗することを確認
    - テストがパスするだけの最小限のコードを記述し、それが正しく実装されることを検証
    - コードのリファクタリングを行う。終わったらテストがパスすることを確認
- TDDの落とし穴
    - テストのカバレッジが100％になるように法外な時間をテストに費やしていしまう
    - 冗長なテストを多く容易してしまう
    - 設計がボトムアップになりがち

### ボトムアップ vs トップダウン vs 本来あるべき方法

- トップダウン
    - 解決すべき全体的な問題を分割する
- ボトムアップ
    - 家を建てるようにコードをつくる
- どちらの視点にもかけているもの
    - 開発の開始時点では、自らが何をやっているのかわからない
- **トップダウンでもボトムアップでもなくて、エンドツーエンドで構築していく**
- ソフトウェアを構築していく唯一の方法はインクリメンタルに進めていくこと
- とにかくTDDを実践する
- 全体的な展望を見失わない

### TDD：目的を知っておく必要がある

- 問題の全貌を把握できないときは、少しづつ何度もテストしながら進んでいく
- 本来の開発目的を無視して簡単な問題を際限なく洗練させていくよう促してしまうという落とし穴もある

### テストしやすいコード

- コンポーネントベースの開発は、偉大な目標として長い間人々が探し求めてきた
- ハードウェアのチップのように、初期の段階からソフトウェア中にテスト機構を組み込んでおき、接続前にテストを実行する

### ユニットテスト

- モジュールごとにそれぞれ独立した形でその振る舞いを検証する

### 契約に対するテスト

- 契約が遵守されていることを確認するためのテストケースを記述する必要がある
    - コードが契約に合致しているか
    - 契約の意味が考えている通りのものか
- **テスト設計を行うこと**

### アドホックなテスト

- コードを手作業で突きまわして実行するその場限りのテスト
    - console.log
    - デバッガー
    - 対話インターフェース

### テストウィンドウを構築する

- 最高のテストを持ってしてもすべてのバグを発見しつくすことはできない
- ソフトウェアが本番環境に配備されてからも実世界のデータを流し込むテストが必要であるということを意味している
- トレースメッセージを書き込んだログファイル
    - 自動的に解析可能
    - 規則正しい
    - 整合性のある
- ホットキーシーケンス
    - ある特定のキーを謳歌すると、状態メッセージを表示した状態制御ウィンドウがポップアップする

### 告白

- テストを書くのをやめても多くの変化はない
- テストの利点は、テストと、それがコードに対して及ぼす影響を考えることから来ている
- テストは他の開発者とのコミュニケーションの接点になっている
- テストは記述するべき

### テスト文化

- テスト計画の選択肢
    - 最初にテスト
        - TDDなどでテストが保証される
    - 開発中にテスト
    - テストしない
        - 最悪
- 常にテストをパスすることを意味している
- テストコードは本番のコードと同じくらい慎重に扱う
- **ソフトウェアをテストすることは、さもなければユーザーにテストを強いることになる**

## プロパティーベースのテスト

- 自分の理解でテストを書くのでパスするはず
- 自分が抱く予想を共有していないコンピュータが、自分のためにテストを実施する代替が適切

### 契約と不変性、プロパティ

- コードに入力として許容される条件と、出力として保証する内容を保持させる（[契約による設計]()）
- 不変性：ある機能の処理を通じて変化することのないものごと
- 契約と不変性をまとめてプロパティと呼ぶ
- **仮定を検証するためにプロパティベースのテストを使用すること**

### テストデータの生成

### まずい仮定を見つけ出す

### プロパティーベースのテストがしばしもたらす驚き

- 入力を生成するデータを生成、出力を検証する仮定を設定してテストする
- 何がおこるかわからない
- 何が失敗の原因なのかを特定しにくいケースが有る
- テスト対象の関数にどのようなパラメーターを渡したのか調べて、その値を用いて一般的なユニットテストを作成すればよい
    - プロパティーベースのテストフレームワークによって実行される追加の呼び出しがない
    - ユニットテストは回帰テストとして機能する

### プロパティベースのテストによる設計支援効果

- プロパティベースのテストは不変性と契約という観点からコードについて考えさせてくれる
- プロパティベースのテストはユニットテストを保管するものである

## 実世界の外敵から身を守る

- ハイジャックやサイバー犯罪のインシデントは開発者の不注意によって発生している

### その他90%

- 作業の90%を完成させても、その他の90%を完成させていない
    - うまくいかなかった手順についてコードの分析
    - テストへの反映
    - 誤ったパラメータの指定
    - リソースのリーク
- 世界は広く、隅々までネットワークに繋がっている

### セキュリティの基本原則

**最小権限の原則を厳守する**

- 複雑なコードはアタックサーフェスを穴だらけにし、感染の危険を増やす
- コードが小さいことはセキュリティホールが少ない

入力データは攻撃ベクターとなる

- 外部からのデータを信頼してはいけない
- データベースに引き渡したり、プレビューしたりする前にサニタイズする

認証の不要なサービスは攻撃ベクターとなる

- DoS攻撃の機会を提供することになる

認証を要するサービスは攻撃ベクターとなる

- 権限を付与するユーザーの数は最小限に留める

出力データは攻撃ベクターとなる

- 出力するデータがそのユーザーの認証に適切かを確認するようにする
- IDなどの危険を呼び起こす可能性のある情報は、切り落としたり曖昧な形にする

デバッグ情報は攻撃ベクターとなる

- 実行時の例外レポートは盗み見されないようにする
- **KISSの原則を守り、アタックサーフェスを最小化する**

**最小権限の原則を厳守する**

- その作業で本当に必要になった権限だけを昇格し、終わった時点ですぐにもとに戻す

デフォルトをセキュアなものにする

機密データを暗号化する

- プレインテキストのままで置いておかない
- 秘密にしておきたい情報はバージョン管理にチェックインしない
- 環境変数で管理する

### パスワードのアンチパターン

- 厳格なパスワードを要求してもセキュリティは強化されるわけではない
- NISTの推奨事項を読む
- 長くランダムなパスワードを推奨する

**セキュリティアップデートを適用する**

- **セキュリティパッチはすぐに適用すること**

### 常識 VS. 暗号

- 暗号化機能を自らの手で作り出そうとしてはいけない
    - エキスパートに一瞬で破られる
- 詳しい専門家に頼んでサードパーティの認証プロバイダーを利用するのもよい

## ものの名前

- コード内での役割に沿った名前をつけるべき
    - これをつくる動機はなんだったっけ？と考える

## 規約に対する例外

- コードで使用する名前には明確さは必要だが、プロジェクトやプロジェクトチームの名前には曖昧で気の利いた名前をつけることが昔からの伝統となっている

### 文化を尊重する

- ループカウンタのi,j,k
- キャメルケース、スネークケース

### 首尾一貫性

- チームの全員が単語の持つ意味を理解して、守備一貫した形で使用することが重要
    - 多くのコミュニケーションを奨励する
    - ペアプロ
- パターン・ランゲージになる

### 名前の変更はかなり難しい

- 問題を見つけたらすぐに修正する
- **適切な名前をつけ、必要に応じてリネームすること**
