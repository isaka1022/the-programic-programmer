# コーディング段階

- プロジェクトがコーディング段階に入ると機会的に実行可能？
- こうした考えはシステムを悪くする
- コーディングは機会的な作業ではない
- 本能的で無意識の思考を活用できるようになる
- コードについて積極的に考えようとしない開発者は偶発的にプログラミングを実践している
- 自分自信で書いたコードに常に批判的な目を向ける
- テストはバグを発見するためのものではない
    - コードのフィードバック、設計やAPI、結合といった観点をえるためのもの
    - テストの主な利点は、テストについて考え、テストを生み出しているときに生み出される
- 名前によって作り出す現実そのものが様々な形で定義されていくことになる
- 状況を再検討し、問題の可能性をチェックし、不測の事態に備えている

## 爬虫類脳からの声に耳を傾ける

- 洗練された人間として、憤らんお本能、爬虫類脳を理解するように学習してきた
- プログラマーとして経験を積んでいくとともに、うまくいくものごと、うまく行かないものごと、問題が起こりそうな状況が蓄積されていく
- 無意識のうちに脳の「ファイル保存」ボタンが押されてリウ
- 本能は言葉で表せない

### 空白ページの恐怖

- 作業に対して最初の一歩を遅らせようとする原因
    - 作業を前にしてなにか疑いが感じられる場合や気が進まない場合、過去の経験が何かを伝えようとしているのかもしれない
    - 単に失敗を恐れている

### 自らと戦う

- コーディングがぬかるんだ上り坂を登っていくように感じられるとき
- コードが何かを伝えようとしている
    - 構造や設計が間違っている
    - 誤った問題を解決しようとしている
    - 星の数くらいの多くのバグを作ろうとしている

### 爬虫類脳との対話方法

- **爬虫類脳に耳を傾ける**
- 作業の手を止める
    - キーボードから少し離れて別のことをする
- 問題を具体的な形にして表現してみる
    - 開発中のコードに関することをチラシの裏に書き付けてみる
    - プログラマー以外の同僚に説明してみる
- 脳の違った部分を用いて問題が他のやり方で扱えないかを見極める
- プロトタイピングして、今からやろうとしていることがそれほど大きな話でないと脳に伝える

### お遊びの時間

- 自分自身に向けて、プロトタイプの必要性を呼びかける
- プロジェクトで探求したい側面に目を向ける
    - 新しいフレームワークを使っている
    - データの束縛方法について深ぼる
    - アルゴリズムで境界条件の動作を探求する
    - ユーザーインタラクションの方法を今までと違った形にする
- 既存のコードを相手に手こずっている場合
    - ポストイットに「現在プロトタイピング中」と書いて、画面の横に貼る
    - 失敗するために実施するということを忘れない
    - 失敗しなかったとしてもプロトタイプは捨て去る
    - 実行すること、学習することを1行にまとめてまっさらなエディタの画面にコメントとして記述
    - コーディングを開始
- コーディング中にぼんやりとした不安が具体化したら、その問題に取り組む
- 意外と楽しくコードを記述できることに気づく
    - そうしたら作業に戻れば良い！

### 「あなたのコード」だけではない

- 他人のコードと格闘することも作業の多くになる
- コードを機械的に読みすすめ、重要と思われる内容をコメントしていくことも無益でない
- ちょっとした実験
    - 見知らぬ方法で実装されているところを見つけたら手早くメモる
    - パターンが見つかるとコードへの理解が一気に深まる

### コードに留まらない

- コード以外でも要件定義や設計時にも不安を感じたら、立ち止まって分析するようにする

## 偶発的プログラミング

- 開発者も地雷原で働いているようなもの
- 幸運と行き当たりばったりの成功に頼るような偶発的プログラミングを避けて、「慎重なプログラミング」を選ぶべき

### 偶発的プログラミングの方法

- なぜコードが動いていたかを理解していなかったので動かなかったときもその理由がわからなかった
- 偶然の結果と意図的な行為の結果をごちゃまぜにしてしまうこともある

実装の事故

- コードが現在そのように記述されているという、ただそれだけの理由で発生する
- ドキュメント化されていないエラーや境界条件に頼っている点からくる
- 「とにかく今動いているんだから触らないほうがいいな」が間違っている理由
    - 本当は動いているように見えて動いていないかもしれない
    - 前提としている境界条件は偶発的なものであるかもしれない（画面解像度、CPUコア数）
    - ライブラリの次のリリースでドキュメント化されていない動作がへんこうになるかもしれない
    - 不必要な呼び出しが余分にあるとコードの実行が遅くなる
    - 余計な呼び出しによって、新たなバグを混入させてしまう危険性がある
- 他人の使うコードを開発している場合、基本原則を適用する
    - 正しいモジュール
    - コンパクトかつ上手にドキュメント化されたインタフェースの背後に実装を隠す
    - [契約による設計]()
- 機能を呼び出すときには。ドキュメント化された振る舞いのみを前提とする

十分近い、というのは外れも同じ

- e.g タイムゾーンの1時間を許容したらコードに意味不明な+1や-1が増えていた

幻のパターン

- つるふさの法則
    - 偶然でも、パターンと原因を見極めようとする
- 仮定でなく証明が必要

コンテキストの事故

- モジュールはGUIを前提としたものでよいか？
- ユーザーは日本語を話すことを前提としてよいか？
- 読み書きができるユーザーを前提として良いか？
- カレントディレクトリが書込み可能であることを前提としていないか？
- 環境変数や設定ファイルの存在が前提になっていないか？
- サーバーが正常に動作している際にどの程度の許容度があるか
- ネットワークの可用性と速度に依存していないか
- あなたが前提としていることで、保証できないものはないか？
- コードをコピーする際には、同じコンテキストにあるといってよいか
- **偶発的プログラミングを行わないこと**

暗黙の仮定

- すべての段階で、人々は心のなかに多くの仮定を置いている
- こうした仮定はドキュメント化されることははほとんどない

### 慎重なプログラミングの方法

- 何をやっているのかを意識する
    - [石のスープとゆでガエル]() のようにならないように
- 新人プログラマーに対して、コードの詳細を説明できるように
- 完全に理解していないアプリケーションをを作成したり、なじみのない技法を使わない
- 明確なプランを作る
- 信頼のおけるものごとだけを前提とする
- 仮定をドキュメント化する
- コードだけでなく、置いた仮定もテストする
    - [表明]()を記述する
- 作業に優先順位をつけ、重要な部分に時間をかけるようにする
- 陳腐化したコードがあったら、それが全部でも置き換える

## アルゴリズムのスピード

- アルゴリズムや消費する時間やプロセッサ、メモリなどのリソースの見積もりを行う

### アルゴリズム見積もりとは

- アルゴリズムの入力サイズに対する計算量
- より詳細な分析を行う必要があるときにはO記法を使う

### O記法

- 測定対象の上限値を表すもの

### 見積もりについての一般的心得

- 単純ループ $O(n)$
    - 順次検索、配列中の最大値取得、チェックサムの生成
- ネストしたループ $O(n^2)$
    - バブルソート
- 二分割 $O(lg(n))$
    - クイックソート
- 組み合わせ
    - 巡回セールスマン問題、ナップサック問題、数値の集合を分割して各集合の合計を同じにする

### 現実的なアルゴリズムのスピード

- ソートの処理を仕事で開発するようなことはないはず：ライブラリを使用する
- 単純なループを記述するときでもオーダーを意識する
- **アルゴリズムのオーダーを見積もること**
- コードの実行時間やメモリの使用量がわからないのであれば、入力件数や実行時間に影響を与えそうなものを変えてみて実行してみて確認する
    - 実際に測定、グラフ化
- コード自身が何をしているのかを考慮
    - nが小さい場合には別の方が早くなることお
- 達人プログラマーあは理論面および現実面の双方でものごとを考えなければならない
- 見積もりの本来の目的は、本番環境上で実際のデータを使ってそのコードを実行したときの速度
- **見積もりの検証を行うこと**

最善は常に最善ではない

- 最高速のアルゴリズムが今の仕事にとって最善のものであるとは必ずしもいえない
- 時期尚早な最適化にも注意が必要
    - アルゴリズムの改良は、それが本当にボトルネックになっていることを確認してから行うべき
