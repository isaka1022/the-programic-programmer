# 柳に雪折れ無し

- コードに柳の枝のような柔軟性をもたせることができれば、雪の重みという外界の変化に負けないようになる

## 分離

- コンポーネント間の結合をできる限り減らすべき
- **分離されたコードは変更しやすい**
- グローバリゼーション
    - 静的なものに潜むわな
- 相続問題
    - サブクラス化が危険な理由
- 気をつけるべき結合の症状
    - 無関係なモジュールやライブラリとの奇妙な依存関係
    - システム中の無関係なモジュールに伝播していく、単一なモジュールへの「シンプル」な変更
    - どういった影響が引き起こされるかわからないため、コードの変更に恐れを抱く開発者
    - 変更によって誰の担当に影響が及ぶかがわからないために全員参加が矯正されるミーティング

### 列車の衝突事故：メソッド呼び出しの連鎖
- コードの変更箇所の判断基準として、責務について考える
- 照会せずに依頼する（TDA, Tell, Don't Ask）
- オブジェクトの内部状態に基づく意思決定をし、その結果で該当オブジェクトを更新してはならない
- あらゆるアプリケーションには普遍的なトップレベルのコンセプトが存在
    - 「顧客」や「注文」など

デルメルの法則：LoD

- クラス「C」に定義されたメソッドは以下のアクセスのみを行うべき
    - C内に定義された他のインスタンスメソッド
    - そのパラメーター
    - スラック上やヒープ内に格納されているオブジェクトに関連づけられているメソッド
    - 大域変数
- **メソッド呼び出しを連鎖させないこと**
- 例外：連鎖させようとしているものが本当に変更される可能性がない場合
    - 言語に付随してくるライブラリとか

連鎖とパイプライン

- データを変換し、ある機能から次の機能に引き渡す
- データの形式は次の機能が受け入れる形式と互換性がなければいけない

### グローバリゼーション

- **大域データを避ける**

大域データにはsingletonも含まれる

- インスタンス変数を保持したSingletonも大域データである

大域データには外部リソースも含まれる

- 大域データにするだけの重要なものである場合、APIでラップする

### 相続問題：サブクラス化が危険な理由

### もう一度：全ては変更についてである

- 結合されたコードの変更は大変
- コードが直接知っていることのみを実行できるようにする

## 実世界を扱う

- レスポンシブなアプリケーション開発

### イベント

- 情報の利用可能性
- イベントに応答するための4つの戦略
    - 有限状態機械（FSM）
    - Observerパターン
    - Publish/Subscribeプロトコル
    - リアクティブプログラミングとストリーム、イベント

### 有限状態機械

- とても簡単である

実践的FSMのススメ

- イベントに対してどのように振る舞うのかを規定したものでしかない
- 一連の状態で構成
    - いずれかが現在の状態
    - イベントごとにシステムが遷移する次の状態が定義されている

アクションの追加

- 純粋なFSMはイベントのストリームに対するパーサー

有限状態機械を出発点に

- あまり開発では活用されていない
- 積極的に活用してほしい

### Observer パターン

- 観測可能イベントの発生源とそのイベントに関連付けられたオブザーバーと呼ばれるクライアントのリストを管理することになる
- オブザーバーは興味のある観測可能な対象に向けて、呼び出してほしい関数への参照を引き渡す
- その後、イベントが発生した場合、その観測可能な対象は、オブザーバーのリストに登録された関数を順番に呼び出していく
- 関数呼び出しにはこのイベント自体が引数として渡される
- 観測可能な対象を作成するためのコードはさほど大きなものではない
- 関数への参照をリストに追加し、イベントが発生した際にこれらの関数を呼び出すだけ
- ライブラリを使わない場合における優れた例
- ユーザーインタフェースシステムにおいて、何らのインタラクションが発生した際にコールバックによってアプリケーションにその旨を知らせるという局面で特に多用される
- オブザーバーは観測可能な対象に登録しないといけないが、結合を導入することになる
- コールバックの実装では観測可能な対象の処理と同じスレッド内でコールバックが逐次的に処理されることになる

PUblish/Subscribeプロトコル

- Observerパターンを一般化すると同時に結合とパフォーマンスの問題を解決する
- パブリッシャーとサブスクライバーを用意する
    - チェンネルを介して接続
        - ライブラリ、プロセス、分散インフラなどコード本体から切り離された形で実装
        - 実装の詳細はコードから隠蔽
        - すべてのチャンネルには名前がつく
    - サブスクライバーはチャンネルの中から興味があるものを登録し、パブリッシャーはイベントをチャンネルに書き込む
    - パブリッシャーとサブスクライバー間の通信はコード以外のところで潜在的かつ非同期に行われる
- pubsubライブラリを使用するのがおすすめ
- アプリケーションを実行中でも既存のコードを変更することなくコードを追加したり変更したりすることができるようになる
- 過度に使用するとどこで問題が起こっているかわからなくなる
- Observerパターンに比べて共有インターフェースを通じた抽象化によって結合を引き下げる素晴らしい例
- イベントの組み合わせに対応するシステムを作るにはさらなる処理が必要

### リアクティブプログラミングとストリーム、イベント

- 他のセルが変わったときに反応（React）する
- ストリームを用いることでイベントをデータのコレクションとして扱える
- 操作や結合、フィルタリングなどデータに対して適用できるすべてのことができる
- 非同期にもできる
- [http://reactivex.io](http://reactivex.io) にてリアクティブなイベント処理における現時点でのデファクトが定義されている

イベントのストリームは非同期のコレクション

- ユーザーリストは静的なもの
- セッションが作成されたときにそのユーザーIDを保持した観測可能イベントを生成し、観測可能なものにする
- 時間を管理対象として扱わなくてもよくなる
- イベントストリームによって一般的かつ扱いやすいAPIの背後で同期処理と非同期処理が実行される

### イベントはユビキタスなもの

- イベントを中心にしたコードは、直列的に処理をしていくコードよりもよりレスポンシブで、より分離したものになる
